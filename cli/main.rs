use pnet::datalink;
use anyhow::Result;
use packet::udp::dhcp::*;
use hex;
use bytes::{Bytes, BytesMut};
use tokio::{self, net::UdpSocket};


#[tokio::main]
async fn main() -> Result<()> {
    let interfaces = datalink::interfaces();
    println!("网卡数: {}", interfaces.len());
    for interface in interfaces.into_iter() {
        println!("网络 - name: {} MAC: {}", interface.description, interface.mac.unwrap_or_default());
    }
    let socket = UdpSocket::bind("0.0.0.0:68").await?;
    let broadcast = socket.set_broadcast(true);
    if let Ok(r) = broadcast {
        println!("开启广播模式");
    }
    let mut buf = [0; 1024];
    // 0000   01 01 06 00 99 c0 cd 35 00 00 00 00 00 00 00 00
    // 0010   00 00 00 00 00 00 00 00 00 00 00 00 08 00 27 0f
    // 0020   be 55 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    // 0030   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    // 0040   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    // 0050   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    // 0060   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    // 0070   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    // 0080   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    // 0090   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    // 00a0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    // 00b0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    // 00c0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    // 00d0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    // 00e0   00 00 00 00 00 00 00 00 00 00 00 00 63 82 53 63
    // 00f0   35 01 01 3d 07 01 08 00 27 0f be 55 32 04 c0 a8
    // 0100   38 66 0c 0f 44 45 53 4b 54 4f 50 2d 52 41 44 44
    // 0110   4c 4a 45 3c 08 4d 53 46 54 20 35 2e 30 37 0e 01
    // 0120   03 06 0f 1f 21 2b 2c 2e 2f 77 79 f9 fc ff

    // 0101060099c0cd3500000000000000000000000000000000000000000800270fbe5500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000638253633501013d07010800270fbe553204c0a838660c0f4445534b544f502d524144444c4a453c084d53465420352e30370e0103060f1f212b2c2e2f7779f9fcff
    let mut dicover_bytes = BytesMut::new();
    dicover_bytes.extend(&[0x01, 0x01, 0x06, 0x00, 0x99, 0xc0, 0xcd, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
    dicover_bytes.extend(&[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x27, 0x0f]);
    dicover_bytes.extend(&[0xbe, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
    dicover_bytes.extend(&[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
    dicover_bytes.extend(&[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
    dicover_bytes.extend(&[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
    dicover_bytes.extend(&[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
    dicover_bytes.extend(&[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
    dicover_bytes.extend(&[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
    dicover_bytes.extend(&[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
    dicover_bytes.extend(&[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
    dicover_bytes.extend(&[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
    dicover_bytes.extend(&[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
    dicover_bytes.extend(&[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
    dicover_bytes.extend(&[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x82, 0x53, 0x63]);
    dicover_bytes.extend(&[0x35, 0x01, 0x01, 0x3d, 0x07, 0x01, 0x08, 0x00, 0x27, 0x0f, 0xbe, 0x55, 0x32, 0x04, 0xc0, 0xa8]);
    dicover_bytes.extend(&[0x38, 0x66, 0x0c, 0x0f, 0x44, 0x45, 0x53, 0x4b, 0x54, 0x4f, 0x50, 0x2d, 0x52, 0x41, 0x44, 0x44]);
    dicover_bytes.extend(&[0x4c, 0x4a, 0x45, 0x3c, 0x08, 0x4d, 0x53, 0x46, 0x54, 0x20, 0x35, 0x2e, 0x30, 0x37, 0x0e, 0x01]);
    dicover_bytes.extend(&[0x03, 0x06, 0x0f, 0x1f, 0x21, 0x2b, 0x2c, 0x2e, 0x2f, 0x77, 0x79, 0xf9, 0xfc, 0xff]);
    // let discovery_message = DHCPDiscover{xid: [0x99, 0xc0, 0xcd, 0x35], mac: "18:00:27:0f:be:56".to_owned()};
    let discovery_message = DHCPDiscover::with_mac("F6-6D-3F-C0-8A-6E");
    let tmp_bytes = discovery_message.to_bytes();

    // let broadcast_result = socket.send_to(&dicover_bytes, "255.255.255.255:67").await;
    let broadcast_result = socket.send_to(&tmp_bytes, "255.255.255.255:67").await;
    match broadcast_result {
        Ok(n) => println!("发送数据包: {}", n),
        Err(e) => println!("错误: {:?}", e)
    }
    loop {
        let (len, addr) = socket.recv_from(&mut buf).await?;
        println!("{:?} bytes received from {:?}", len, addr);
    }
}
